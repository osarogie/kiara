# Autogenerated input type of ChangePassword
input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
  newPasswordConfirmation: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of ChangePassword
type ChangePasswordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [UserError!]!
  success: Boolean
  user: User
}

# A spectrum
type Color {
  primary: String
  primaryHeaderText: String
  secondary: String
  secondaryHeaderText: String
}

# A discussion
type Comment implements Node {
  _id: ID!
  body: String
  createdAt: Int
  discussion: Discussion
  discussionId: ID!
  excerpt(size: Int = 30): String
  id: ID!
  parsedBody: String
  updatedAt: Int
  user: User
  userId: ID!
}

# The connection type for Comment.
type CommentConnection {
  # A list of edges.
  edges: [CommentEdge]

  # A list of nodes.
  nodes: [Comment]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CommentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Comment
}

# Autogenerated input type of CreateComment
input CreateCommentInput {
  body: String!
  discussionId: ID!
  photo: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateComment
type CreateCommentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comment: Comment
  success: Boolean
}

# Autogenerated input type of CreateDiscussion
input CreateDiscussionInput {
  name: String!
  body: String!
  groupId: ID
  photo: String
  isHtml: Boolean
  hidePoll: Boolean
  pollCloseDate: String
  pollCloseTime: String
  discussionOptionsAttributes: [DiscussionOptionsInputType!]
  content: DraftContentInput

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateDiscussion
type CreateDiscussionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  discussion: Discussion
  success: Boolean
}

# Autogenerated input type of CreateGroup
input CreateGroupInput {
  name: String!
  tagline: String
  body: String
  isPrivate: Boolean
  headerImage: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateGroup
type CreateGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
  query: Query
  success: Boolean
}

# Autogenerated input type of DeleteComment
input DeleteCommentInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DeleteComment
type DeleteCommentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comment: Comment
  deletedId: ID!
}

# Autogenerated input type of DeleteDiscussion
input DeleteDiscussionInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DeleteDiscussion
type DeleteDiscussionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deletedDiscussionId: ID!
  discussion: Discussion
}

# Autogenerated input type of DeleteGroup
input DeleteGroupInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DeleteGroup
type DeleteGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deletedId: ID!
  group: Group
}

# Autogenerated input type of DeleteUser
input DeleteUserInput {
  password: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DeleteUser
type DeleteUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deletedId: ID!
  user: User
}

# A discussion
type Discussion implements Node {
  _id: ID!
  body: String
  commentCount: Int
  comments(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    byLatest: Boolean = false
  ): CommentConnection
  content: DraftContent
  createdAt: Int
  excerpt(size: Int = 30): String
  featurePhoto: Photo
  group: Group
  hasPoll: Boolean
  hideVotes: Boolean
  id: ID!
  likeCount: Int
  likes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): LikeConnection
  name: String
  otherUsersPosts(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DiscussionConnection
  parsedBody: String
  parsedExcerpt(size: Int = 30): String
  permalink: String
  poll(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DiscussionOptionConnection
  pollClosesAt: Int
  publicUrl: String
  readingTime: String
  reads: String
  related(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DiscussionConnection
  updatedAt: Int
  user: User
  viewerDoesLike: Boolean
  viewerHasVoted: Boolean
  viewerOwns: Boolean
  voteCount: Int
  votingHasEnded: Boolean
  wordCount: Int
}

# The connection type for Discussion.
type DiscussionConnection {
  # A list of edges.
  edges: [DiscussionEdge]

  # A list of nodes.
  nodes: [Discussion]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type DiscussionEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Discussion
}

# A Poll Choice
type DiscussionOption implements Node {
  _id: ID!
  createdAt: Int
  discussion: Discussion
  discussionId: ID!
  id: ID!
  title: String
  viewerSelected: Boolean
  voteCount: Int
}

# The connection type for DiscussionOption.
type DiscussionOptionConnection {
  # A list of edges.
  edges: [DiscussionOptionEdge]

  # A list of nodes.
  nodes: [DiscussionOption]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type DiscussionOptionEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: DiscussionOption
}

# A Poll Choice input
input DiscussionOptionsInputType {
  id: String
  title: String!
  _destroy: String!
}

# DraftBlock
type DraftBlock {
  data: DraftData
  depth: Int
  entityRanges: [DraftEntityRange]
  inlineStyleRanges: [DraftInlineStyleRange]
  key: String
  text: String
  type: String
}

# DraftBlockInput
input DraftBlockInput {
  key: String!
  text: String
  type: String!
  depth: Int!
  inlineStyleRanges: [InlineStyleRangeInputType!]
  entityRanges: [EntityRangeInputType!]
  data: DraftDataInput
}

# DraftContent
type DraftContent {
  blocks: [DraftBlock]
  entityMap: [DraftEntity]
}

# DraftContentInput
input DraftContentInput {
  blocks: [DraftBlockInput!]!
  entityMap: [DraftEntityInput!]
}

# DraftData
type DraftData {
  href: String
}

# DraftDataInput
input DraftDataInput {
  href: String
}

# DraftEmbedData
type DraftEmbedData {
  html: String
  type: String
  url: String
}

# DraftEntity
type DraftEntity {
  data: DraftEntityData
  mutability: DraftEntityMutability
  type: String
}

# Holds a link or an embed
union DraftEntityData = DraftEmbedData | DraftImageData | DraftLinkData

# DraftEntityDataInput
input DraftEntityDataInput {
  type: String
  url: String
  html: String
  href: String
  target: String
  size: String
  align: String
  width: Int
  height: Int
  caption: DraftContentInput
}

# DraftEntityInput
input DraftEntityInput {
  type: String
  mutability: DraftEntityMutability
  data: DraftEntityDataInput
}

# DraftEntityMutability
enum DraftEntityMutability {
  MUTABLE
  IMMUTABLE
  SEGMENTED
}

# DraftEntityRange
type DraftEntityRange {
  key: Int
  length: Int
  offset: Int
}

# DraftImageData
type DraftImageData {
  align: String
  caption: DraftContent
  height: Int
  size: String
  url: String
  width: Int
}

# DraftInlineStyleRange
type DraftInlineStyleRange {
  length: Int
  offset: Int
  style: String
}

# DraftLinkData
type DraftLinkData {
  href: String
  target: String
  type: String
}

# Autogenerated input type of EditComment
input EditCommentInput {
  id: ID!
  body: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of EditComment
type EditCommentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comment: Comment
}

# Autogenerated input type of EditDiscussion
input EditDiscussionInput {
  id: ID!
  name: String
  body: String
  groupId: ID
  photo: String
  isHtml: Boolean
  content: DraftContentInput

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of EditDiscussion
type EditDiscussionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  discussion: Discussion
}

# Autogenerated input type of EditGroup
input EditGroupInput {
  id: ID!
  name: String!
  tagline: String
  body: String
  isPrivate: Boolean
  headerImage: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of EditGroup
type EditGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
  success: Boolean
}

# Autogenerated input type of EditUser
input EditUserInput {
  name: String
  username: String
  email: String
  profilePic: String
  bio: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of EditUser
type EditUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  success: Boolean
  user: User
}

# EntityRangeInputType
input EntityRangeInputType {
  offset: Int!
  length: Int!
  key: Int!
}

# The feed root of this schema
type Feed implements Node {
  discussions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
    since: String
    byLatest: Boolean = false
  ): DiscussionConnection
  groups(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
    since: String
    byLatest: Boolean = false
  ): GroupConnection
  id: ID!
  topStories(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DiscussionConnection
  users(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
    since: String
    byLatest: Boolean = false
  ): UserConnection
}

# Autogenerated input type of FollowUser
input FollowUserInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of FollowUser
type FollowUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user: User
}

# A group
type Group implements Node {
  _id: ID!
  body: String
  colorScheme: Color
  createdAt: Int
  discussions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    byLatest: Boolean = false
  ): DiscussionConnection
  headerImage: Photo
  id: ID!
  isPrivate: Boolean
  name: String
  permalink: String
  publicUrl: String
  tagline: String
  updatedAt: Int
  user: User
  userCount: Int
  users(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UserConnection
  viewerIsAMember: Boolean
  viewerIsOwner: Boolean
}

# The connection type for Group.
type GroupConnection {
  # A list of edges.
  edges: [GroupEdge]

  # A list of nodes.
  nodes: [Group]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type GroupEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Group
}

# InlineStyleRangeInputType
input InlineStyleRangeInputType {
  offset: Int!
  length: Int!
  style: String!
}

# Autogenerated input type of JoinGroup
input JoinGroupInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of JoinGroup
type JoinGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of LeaveGroup
input LeaveGroupInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of LeaveGroup
type LeaveGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# A like
type Like implements Node {
  _id: ID!
  discussion: Discussion
  id: ID!
  user: User
  userId: ID!
}

# The connection type for Like.
type LikeConnection {
  # A list of edges.
  edges: [LikeEdge]

  # A list of nodes.
  nodes: [Like]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# Autogenerated input type of LikeDiscussion
input LikeDiscussionInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of LikeDiscussion
type LikeDiscussionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  discussion: Discussion
}

# An edge in a connection.
type LikeEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Like
}

# Autogenerated input type of LoginUser
input LoginUserInput {
  username: String!
  password: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of LoginUser
type LoginUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  token: String
  user: User
}

# Autogenerated input type of Logout
input LogoutInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of Logout
type LogoutPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# The mutation root for this schema
type Mutation {
  # Edit a users password and return user
  changePassword(
    # Parameters for ChangePassword
    input: ChangePasswordInput!
  ): ChangePasswordPayload

  # Create comment for a comment and return comment and new comment
  createComment(
    # Parameters for CreateComment
    input: CreateCommentInput!
  ): CreateCommentPayload

  # Create discussion for a discussion and return discussion and new discussion
  createDiscussion(
    # Parameters for CreateDiscussion
    input: CreateDiscussionInput!
  ): CreateDiscussionPayload

  # Create group
  createGroup(
    # Parameters for CreateGroup
    input: CreateGroupInput!
  ): CreateGroupPayload

  # Delete a comment and return comment and deleted comment ID
  deleteComment(
    # Parameters for DeleteComment
    input: DeleteCommentInput!
  ): DeleteCommentPayload

  # Delete a discussion and return discussion and deleted discussion ID
  deleteDiscussion(
    # Parameters for DeleteDiscussion
    input: DeleteDiscussionInput!
  ): DeleteDiscussionPayload

  # Delete a group and return group and deleted group ID
  deleteGroup(
    # Parameters for DeleteGroup
    input: DeleteGroupInput!
  ): DeleteGroupPayload

  # Delete a user and return user and deleted user ID
  deleteUser(
    # Parameters for DeleteUser
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Edit a comment and return comment
  editComment(
    # Parameters for EditComment
    input: EditCommentInput!
  ): EditCommentPayload

  # Edit a discussion and return discussion
  editDiscussion(
    # Parameters for EditDiscussion
    input: EditDiscussionInput!
  ): EditDiscussionPayload

  # Edit a group and return group
  editGroup(
    # Parameters for EditGroup
    input: EditGroupInput!
  ): EditGroupPayload

  # Edit a user and return user
  editUser(
    # Parameters for EditUser
    input: EditUserInput!
  ): EditUserPayload

  # Follow user
  followUser(
    # Parameters for FollowUser
    input: FollowUserInput!
  ): FollowUserPayload

  # Join group
  joinGroup(
    # Parameters for JoinGroup
    input: JoinGroupInput!
  ): JoinGroupPayload

  # Leave group
  leaveGroup(
    # Parameters for LeaveGroup
    input: LeaveGroupInput!
  ): LeaveGroupPayload

  # Like discussion
  likeDiscussion(
    # Parameters for LikeDiscussion
    input: LikeDiscussionInput!
  ): LikeDiscussionPayload

  # Login user for a user and return user and new user
  login(
    # Parameters for LoginUser
    input: LoginUserInput!
  ): LoginUserPayload

  # Logout a user
  logout(
    # Parameters for Logout
    input: LogoutInput!
  ): LogoutPayload

  # Send a reset token to the user's email
  requestPasswordResetToken(
    # Parameters for RequestPasswordResetToken
    input: RequestPasswordResetTokenInput!
  ): RequestPasswordResetTokenPayload

  # Reset a user's password and return user
  resetPassword(
    # Parameters for ResetPassword
    input: ResetPasswordInput!
  ): ResetPasswordPayload

  # Unfollow user
  unfollowUser(
    # Parameters for UnfollowUser
    input: UnfollowUserInput!
  ): UnfollowUserPayload

  # Unlike a discussion and return discussion
  unlikeDiscussion(
    # Parameters for UnlikeDiscussion
    input: UnlikeDiscussionInput!
  ): UnlikeDiscussionPayload
  updateReads(
    # Parameters for UpdateReads
    input: UpdateReadsInput!
  ): UpdateReadsPayload

  # Vote on a poll
  vote(
    # Parameters for Vote
    input: VoteInput!
  ): VotePayload
}

# An object with an ID.
interface Node {
  # ID of the object.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# A photo
type Photo implements Node {
  _id: ID!
  height: Int
  id: ID!
  name: String
  url(size: String = ""): String
  width: Int
}

# The query root of this schema
type Query {
  # Get blog site information
  blog(domain: String): Group

  # Checks if the password reset token is valid
  checkPasswordResetToken(token: String!): User

  # Find specific user
  comment(id: ID!): Comment

  # Find specific discussion
  discussion(id: ID!): Discussion

  # Root object to get feed
  feed: Feed

  # Find specific group
  group(id: ID!): Group

  # Fetches an object given its ID.
  node(
    # ID of the object.
    id: ID!
  ): Node

  # Fetches a list of objects given a list of IDs.
  nodes(
    # IDs of the objects.
    ids: [ID!]!
  ): [Node]!
  popularUsers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UserConnection

  # Root object to search models
  search: Search

  # Find specific user
  user(id: ID!): User

  # Current user
  viewer: User
}

# Autogenerated input type of RequestPasswordResetToken
input RequestPasswordResetTokenInput {
  # An Email or Username
  identifier: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of RequestPasswordResetToken
type RequestPasswordResetTokenPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  message: String
}

# Autogenerated input type of ResetPassword
input ResetPasswordInput {
  token: String!
  password: String!
  passwordConfirmation: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of ResetPassword
type ResetPasswordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  success: Boolean
  user: User
}

# The search root of this schema
type Search implements Node {
  discussions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
  ): DiscussionConnection
  groups(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
  ): GroupConnection
  id: ID!
  users(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    q: String
  ): UserConnection
}

# Autogenerated input type of UnfollowUser
input UnfollowUserInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of UnfollowUser
type UnfollowUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user: User
}

# Autogenerated input type of UnlikeDiscussion
input UnlikeDiscussionInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of UnlikeDiscussion
type UnlikeDiscussionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deletedId: ID!
  discussion: Discussion
}

# Autogenerated input type of UpdateReads
input UpdateReadsInput {
  id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of UpdateReads
type UpdateReadsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  discussion: Discussion
}

# A user
type User implements Node {
  _id: ID!
  bio: String
  comments(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    byLatest: Boolean = false
  ): CommentConnection
  createdAt: Int
  discussionCount: Int
  discussions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    byLatest: Boolean = false
  ): DiscussionConnection
  followerCount: Int
  followers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UserConnection
  followingCount: Int
  followings(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): UserConnection
  followsViewer: Boolean
  groups(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): GroupConnection
  groupsIn(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): GroupConnection
  id: ID!
  isViewer: Boolean
  name: String
  profilePicture(size: Int = 0): String
  profilePictureName: String
  publicUrl: String
  updatedAt: Int
  username: String
  viewerFollows: Boolean
}

# The connection type for User.
type UserConnection {
  # A list of edges.
  edges: [UserEdge]

  # A list of nodes.
  nodes: [User]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type UserEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: User
}

# A user-readable error
type UserError {
  # A description of the error
  message: String!

  # Which input value this error came from
  path: [String!]
}

# Autogenerated input type of Vote
input VoteInput {
  option: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of Vote
type VotePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  discussion: Discussion!
  message: String!
  success: Boolean!
}
